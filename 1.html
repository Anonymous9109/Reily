<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tiny GTA2-style 2D — Horizontal</title>
<style>
  :root{
    --ui-bg:#0f1724;
    --panel:#0b1220;
    --muted:#9aa6b2;
    --accent:#38bdf8;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{display:flex;gap:8px;background:#071025;color:whitesmoke;padding:12px;box-sizing:border-box}
  /* Layout: wide canvas to enforce horizontal play */
  .left{
    flex:1 1 auto;display:flex;flex-direction:column;gap:8px;
    min-width:640px; /* encourage landscape */
  }
  #canvas-wrap{background:#02040a;border-radius:8px;padding:8px;box-shadow:0 6px 24px rgba(0,0,0,.7);display:flex;justify-content:center;align-items:center;}
  canvas{display:block;border-radius:6px;background:#031124;touch-action:none;}
  .controls{display:flex;gap:8px;align-items:center;}
  button{background:linear-gradient(180deg,#0f1724,#071227);border:1px solid rgba(255,255,255,.06);color:var(--muted);padding:6px 10px;border-radius:6px;cursor:pointer}
  button.primary{background:linear-gradient(180deg,var(--accent),#0ea5c9);color:#022;}
  .panel{
    width:320px;flex:0 0 320px;background:var(--panel);border-radius:8px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,.5);
    display:flex;flex-direction:column;gap:10px;
  }
  h3{margin:0 0 6px 0;font-weight:600;color:var(--muted);font-size:14px}
  .palette{display:flex;gap:8px;flex-wrap:wrap}
  .tile{
    width:48px;height:48px;border-radius:6px;display:flex;align-items:center;justify-content:center;
    border:2px solid transparent;cursor:pointer;font-size:12px;color:#fff;
  }
  .tile.selected{outline:3px solid rgba(255,255,255,.08);transform:translateY(-2px)}
  .tile .label{font-size:11px;color:rgba(255,255,255,.85);text-shadow:0 1px 0 rgba(0,0,0,.8)}
  .mini{width:28px;height:28px;border-radius:4px}
  textarea{width:100%;height:110px;background:#071827;border:1px solid rgba(255,255,255,.04);color:#dfeef8;padding:8px;border-radius:6px;font-family:monospace;resize:vertical}
  .row{display:flex;gap:8px;align-items:center}
  .muted{color:var(--muted);font-size:13px}
  label{font-size:13px;color:var(--muted)}
  .hint{font-size:12px;color:#7f92a0}
  .status{font-size:13px;color:var(--muted)}
  .controls-right{margin-left:auto}
  .small{font-size:12px;padding:6px 8px}
  .flex{display:flex;gap:8px;align-items:center}
  input[type=number]{width:72px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,.04);background:#061423;color:#cfeaf7}
  a.link{color:var(--accent);text-decoration:none}
  footer{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
  <div class="left">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
      <div>
        <h2 style="margin:0 0 4px 0">Tiny GTA2-like — horizontal</h2>
        <div class="hint">Top-down, tile-based. The player is a black dot. Make the map manually with the editor on the right.</div>
      </div>
      <div class="controls">
        <button id="toggleMode" class="primary">PLAY</button>
        <div class="controls-right muted">WASD / Arrow keys to move • click map to paint in EDIT mode</div>
      </div>
    </div>

    <div id="canvas-wrap">
      <!-- Canvas size chosen to be horizontally wide -->
      <canvas id="gameCanvas" width="1280" height="480"></canvas>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-top:10px">
      <div class="status">Mode: <strong id="modeLabel">EDIT</strong></div>
      <div class="status">Player X: <span id="px">0</span> Y: <span id="py">0</span></div>
      <div class="status">Map: <span id="mapSize">0×0</span></div>
    </div>
  </div>

  <aside class="panel">
    <h3>Tile palette</h3>
    <div class="palette" id="palette">
      <!-- tiles added by JS -->
    </div>

    <div>
      <h3>Editor tools</h3>
      <div class="row">
        <button id="fillBtn" class="small">Fill</button>
        <button id="eraseBtn" class="small">Eraser</button>
        <button id="rectBtn" class="small">Rect</button>
        <button id="panBtn" class="small">Pan</button>
        <button id="centerBtn" class="small">Center Player</button>
      </div>
      <div style="margin-top:8px" class="muted">Left-click to paint, right-click to erase. Drag for rectangles when Rect is active.</div>
    </div>

    <div>
      <h3>Map size & generation</h3>
      <div class="row">
        <label>W tiles</label>
        <input type="number" id="mapW" value="120" min="20" max="500">
        <label>H tiles</label>
        <input type="number" id="mapH" value="20" min="8" max="60">
      </div>
      <div style="margin-top:8px" class="row">
        <button id="regenBtn" class="small">Create / Resize</button>
        <button id="clearBtn" class="small">Clear</button>
      </div>
      <div class="hint" style="margin-top:6px">Make the world long horizontally for horizontal feel.</div>
    </div>

    <div>
      <h3>Export / Import map</h3>
      <textarea id="mapJSON" placeholder='Map JSON appears here when you click "Export".'></textarea>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button id="exportBtn" class="small">Export</button>
        <button id="importBtn" class="small">Import</button>
        <button id="downloadBtn" class="small">Download .json</button>
      </div>
    </div>

    <div>
      <h3>Advanced</h3>
      <div class="row">
        <label class="muted">Tile size</label>
        <input type="number" id="tileSize" value="32" min="16" max="64">
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="applyTileSize" class="small">Apply</button>
        <button id="resetCamera" class="small">Reset Camera</button>
      </div>
    </div>

    <footer>
      <div class="muted">Built for manual map editing — paint tiles, export JSON, then play. The player is a black dot centered by default.</div>
      <div style="margin-top:6px"><a class="link" href="#" id="helpLink">Help</a></div>
    </footer>
  </aside>

<script>
/*
Tiny GTA2-like top-down tile game with in-page editor.
- Single-file
- Player = black dot
- Editor: paint tiles, export/import JSON, create map, change tile size
- Camera emphasizes horizontal (canvas is wide)
*/

/* ----- Configuration & tiles ----- */
let tiles = [
  { id:0, name:'Empty', color:'#071428', passable:true },
  { id:1, name:'Wall', color:'#2e3b46', passable:false },
  { id:2, name:'Road', color:'#15313a', passable:true },
  { id:3, name:'Grass', color:'#173d2b', passable:true },
  { id:4, name:'Water', color:'#08324d', passable:false }
];

let state = {
  mode: 'EDIT', // EDIT or PLAY
  tool: 'paint', // paint, erase, rect, pan, fill
  selectedTile: 1,
  tileSize: 32,
  mapW: 120,
  mapH: 20,
  map: null,
  player: { x: 64, y: 64, radius: 8, speed: 160 }, // pixel coords in world
  keys: {},
  camera: { x:0, y:0, w:1280, h:480 },
  mouse: { down:false, start:null, last:null, right:false },
  draggingRect:false
};

/* ----- DOM references ----- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha:false });
const modeLabel = document.getElementById('modeLabel');
const toggleModeBtn = document.getElementById('toggleMode');
const pxEl = document.getElementById('px');
const pyEl = document.getElementById('py');
const mapSizeEl = document.getElementById('mapSize');
const paletteEl = document.getElementById('palette');
const mapJSON = document.getElementById('mapJSON');
const mapWInput = document.getElementById('mapW');
const mapHInput = document.getElementById('mapH');
const tileSizeInput = document.getElementById('tileSize');

/* ----- initialize map and UI ----- */
function createEmptyMap(w,h){
  const m = new Array(h);
  for(let y=0;y<h;y++){
    m[y]=new Array(w).fill(0);
  }
  return m;
}
function ensureMap(){
  if(!state.map || state.map.length !== state.mapH || state.map[0].length !== state.mapW){
    state.map = createEmptyMap(state.mapW, state.mapH);
  }
}
function rebuildPalette(){
  paletteEl.innerHTML='';
  tiles.forEach(t=>{
    const el = document.createElement('div');
    el.className='tile';
    el.dataset.id = t.id;
    el.innerHTML = `<div style="width:100%;height:80%;border-radius:6px;background:${t.color};display:flex;align-items:center;justify-content:center"><span class="label">${t.name}</span></div>`;
    el.addEventListener('click',()=>{ state.selectedTile = t.id; updatePaletteSelection(); });
    paletteEl.appendChild(el);
  });
  updatePaletteSelection();
}
function updatePaletteSelection(){
  Array.from(paletteEl.children).forEach(ch=>{
    ch.classList.toggle('selected', Number(ch.dataset.id) === state.selectedTile);
  });
}
function updateStatus(){
  modeLabel.textContent = state.mode;
  pxEl.textContent = Math.floor(state.player.x);
  pyEl.textContent = Math.floor(state.player.y);
  mapSizeEl.textContent = `${state.mapW}×${state.mapH}`;
}

/* ----- tools: painting, rect, fill, eraser ----- */
function worldToTile(px,py){
  const ts = state.tileSize;
  return { tx: Math.floor(px/ts), ty: Math.floor(py/ts) };
}
function tileToWorld(tx,ty){
  const ts = state.tileSize;
  return { x: tx*ts, y: ty*ts };
}
function paintTileAtWorld(x,y, id){
  const {tx,ty} = worldToTile(x,y);
  if(tx>=0 && tx<state.mapW && ty>=0 && ty<state.mapH){
    state.map[ty][tx] = id;
  }
}
function floodFill(sx,sy, targetId, replacementId){
  if(targetId === replacementId) return;
  const W = state.mapW, H = state.mapH;
  if(sx<0||sx>=W||sy<0||sy>=H) return;
  if(state.map[sy][sx] !== targetId) return;
  const stack = [[sx,sy]];
  while(stack.length){
    const [x,y] = stack.pop();
    if(x<0||x>=W||y<0||y>=H) continue;
    if(state.map[y][x] !== targetId) continue;
    state.map[y][x] = replacementId;
    stack.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
  }
}

/* ----- camera & rendering ----- */
function clampCamera(){
  const worldW = state.mapW * state.tileSize;
  const worldH = state.mapH * state.tileSize;
  // center camera on player but prioritize horizontal offset (wider)
  let cx = state.player.x - state.camera.w/2;
  let cy = state.player.y - state.camera.h/2;
  // small vertical slack to keep mostly horizontal feel
  const verticalSlack = 0.35 * state.camera.h;
  if(Math.abs((state.camera.y + state.camera.h/2) - state.player.y) < verticalSlack){
    // allow slight vertical free movement, so don't center fully
    cy = state.camera.y;
  }
  state.camera.x = Math.max(0, Math.min(worldW - state.camera.w, cx));
  state.camera.y = Math.max(0, Math.min(worldH - state.camera.h, cy));
}
function draw(){
  // clear
  ctx.fillStyle = '#031124';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const ts = state.tileSize;
  const cam = state.camera;
  const startTx = Math.floor(cam.x/ts);
  const endTx = Math.min(state.mapW-1, Math.ceil((cam.x+cam.w)/ts));
  const startTy = Math.floor(cam.y/ts);
  const endTy = Math.min(state.mapH-1, Math.ceil((cam.y+cam.h)/ts));

  // tiles
  for(let y=startTy;y<=endTy;y++){
    for(let x=startTx;x<=endTx;x++){
      const t = state.map[y][x] ?? 0;
      const tile = tiles.find(tt=>tt.id===t) || tiles[0];
      const wx = x*ts - cam.x;
      const wy = y*ts - cam.y;
      // tile fill
      ctx.fillStyle = tile.color;
      ctx.fillRect(Math.round(wx), Math.round(wy), ts, ts);

      // simple grid line
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1;
      ctx.strokeRect(Math.round(wx)+0.5, Math.round(wy)+0.5, ts-1, ts-1);
    }
  }

  // draw player (black dot)
  const px = state.player.x - cam.x;
  const py = state.player.y - cam.y;
  ctx.beginPath();
  ctx.fillStyle = '#000';
  ctx.arc(px, py, state.player.radius, 0, Math.PI*2);
  ctx.fill();

  // player direction indicator (small white)
  ctx.beginPath();
  ctx.fillStyle = '#fff';
  ctx.arc(px, py, Math.max(2, Math.floor(state.player.radius/3)), 0, Math.PI*2);
  ctx.fill();

  // draw editor rectangle if dragging
  if(state.mode==='EDIT' && state.mouse.down && state.tool==='rect' && state.draggingRect && state.mouse.start){
    const s = state.mouse.start;
    const m = state.mouse.last;
    const x1 = Math.min(s.x,m.x), y1 = Math.min(s.y,m.y);
    const x2 = Math.max(s.x,m.x), y2 = Math.max(s.y,m.y);
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.strokeRect(x1 - cam.x, y1 - cam.y, x2 - x1, y2 - y1);
    ctx.setLineDash([]);
  }
}

/* ----- simple collision ----- */
function isPassableWorld(x,y){
  const {tx,ty} = worldToTile(x,y);
  if(tx<0||tx>=state.mapW||ty<0||ty>=state.mapH) return false;
  const t = state.map[ty][tx] ?? 0;
  const tileDef = tiles.find(tt=>tt.id===t) || tiles[0];
  return !!tileDef.passable;
}

/* ----- game loop ----- */
let lastTime = performance.now();
function step(now){
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;

  if(state.mode === 'PLAY'){
    // movement
    const k = state.keys;
    let vx = 0, vy = 0;
    if(k['ArrowLeft'] || k['a']) vx -= 1;
    if(k['ArrowRight'] || k['d']) vx += 1;
    if(k['ArrowUp'] || k['w']) vy -= 1;
    if(k['ArrowDown'] || k['s']) vy += 1;
    // normalize
    if(vx !== 0 || vy !== 0){
      const len = Math.hypot(vx,vy);
      vx /= len; vy /= len;
      const speed = state.player.speed;
      let nx = state.player.x + vx * speed * dt;
      let ny = state.player.y + vy * speed * dt;
      // collision test: sample a few points around circle
      const r = state.player.radius;
      const samples = [
        [nx, ny],
        [nx + r, ny], [nx - r, ny], [nx, ny + r], [nx, ny - r]
      ];
      let ok = true;
      for(const [sx,sy] of samples){
        if(!isPassableWorld(sx,sy)){ ok = false; break; }
      }
      if(ok){
        state.player.x = nx; state.player.y = ny;
      } else {
        // try sliding separately
        let nx2 = state.player.x + vx * speed * dt;
        if(isPassableWorld(nx2, state.player.y)) state.player.x = nx2;
        let ny2 = state.player.y + vy * speed * dt;
        if(isPassableWorld(state.player.x, ny2)) state.player.y = ny2;
      }
    }
    clampCamera();
  } else {
    // in EDIT mode, camera doesn't follow player by default, but we keep camera within map
    const maxCamX = Math.max(0, state.mapW*state.tileSize - state.camera.w);
    const maxCamY = Math.max(0, state.mapH*state.tileSize - state.camera.h);
    state.camera.x = Math.max(0, Math.min(maxCamX, state.camera.x));
    state.camera.y = Math.max(0, Math.min(maxCamY, state.camera.y));
  }

  draw();
  updateStatus();
  requestAnimationFrame(step);
}

/* ----- input handling (mouse & keyboard) ----- */
function getCanvasWorldPos(evt){
  const rect = canvas.getBoundingClientRect();
  const cx = (evt.clientX - rect.left) * (canvas.width / rect.width);
  const cy = (evt.clientY - rect.top) * (canvas.height / rect.height);
  // canvas pixels to world coords: camera offset
  return {
    x: cx + state.camera.x,
    y: cy + state.camera.y
  };
}

canvas.addEventListener('contextmenu', e=>{ e.preventDefault(); });

canvas.addEventListener('pointerdown', e=>{
  canvas.setPointerCapture(e.pointerId);
  state.mouse.down = true;
  state.mouse.right = (e.button===2 || e.ctrlKey);
  const w = getCanvasWorldPos(e);
  state.mouse.start = w;
  state.mouse.last = w;
  if(state.mode === 'EDIT'){
    if(state.tool === 'paint'){
      paintTileAtWorld(w.x,w.y, state.selectedTile);
    } else if(state.tool === 'erase'){
      paintTileAtWorld(w.x,w.y, 0);
    } else if(state.tool === 'fill'){
      const {tx,ty} = worldToTile(w.x,w.y);
      if(tx>=0 && tx<state.mapW && ty>=0 && ty<state.mapH){
        const target = state.map[ty][tx];
        floodFill(tx,ty, target, state.selectedTile);
      }
    } else if(state.tool === 'rect'){
      state.draggingRect = true;
    } else if(state.tool === 'pan'){
      // initiate pan: last stores pointer world position for delta
    }
  }
});

canvas.addEventListener('pointermove', e=>{
  const w = getCanvasWorldPos(e);
  state.mouse.last = w;
  if(state.mode === 'EDIT' && state.mouse.down){
    if(state.tool === 'paint'){
      paintTileAtWorld(w.x,w.y, state.selectedTile);
    } else if(state.tool === 'erase'){
      paintTileAtWorld(w.x,w.y, 0);
    } else if(state.tool === 'pan'){
      // move camera by pointer delta
      const deltaX = (state.mouse.last.x - state.mouse.start.x);
      const deltaY = (state.mouse.last.y - state.mouse.start.y);
      state.camera.x -= deltaX;
      state.camera.y -= deltaY;
      // reset start for continuous pan
      state.mouse.start = state.mouse.last;
    }
  }
});

canvas.addEventListener('pointerup', e=>{
  canvas.releasePointerCapture(e.pointerId);
  state.mouse.down = false;
  const w = getCanvasWorldPos(e);
  if(state.mode === 'EDIT' && state.tool === 'rect' && state.draggingRect){
    state.draggingRect = false;
    // compute tile rect
    const s = state.mouse.start;
    const epos = w;
    const minx = Math.min(s.x, epos.x), miny = Math.min(s.y, epos.y);
    const maxx = Math.max(s.x, epos.x), maxy = Math.max(s.y, epos.y);
    const ts = state.tileSize;
    const tx1 = Math.max(0, Math.floor(minx/ts)), ty1 = Math.max(0, Math.floor(miny/ts));
    const tx2 = Math.min(state.mapW-1, Math.floor(maxx/ts)), ty2 = Math.min(state.mapH-1, Math.floor(maxy/ts));
    for(let ty=ty1; ty<=ty2; ty++){
      for(let tx=tx1; tx<=tx2; tx++){
        state.map[ty][tx] = state.selectedTile;
      }
    }
  }
});

window.addEventListener('keydown', e=>{
  state.keys[e.key] = true;
  // space to center camera on player while in edit
  if(e.key === ' '){ e.preventDefault(); if(state.mode==='EDIT'){ centerCameraOnPlayer(); } }
});
window.addEventListener('keyup', e=>{ delete state.keys[e.key]; });

/* ----- UI buttons ----- */
document.getElementById('toggleMode').addEventListener('click', ()=>{
  if(state.mode === 'EDIT'){
    state.mode = 'PLAY';
    toggleModeBtn.textContent = 'EDIT';
    toggleModeBtn.classList.remove('primary');
    document.activeElement.blur();
    // center camera on player immediately
    clampCamera();
  } else {
    state.mode = 'EDIT';
    toggleModeBtn.textContent = 'PLAY';
    toggleModeBtn.classList.add('primary');
  }
});

document.getElementById('fillBtn').addEventListener('click', ()=>{ state.tool='fill'; updateToolButtons(); });
document.getElementById('eraseBtn').addEventListener('click', ()=>{ state.tool='erase'; updateToolButtons(); });
document.getElementById('rectBtn').addEventListener('click', ()=>{ state.tool='rect'; updateToolButtons(); });
document.getElementById('panBtn').addEventListener('click', ()=>{ state.tool='pan'; updateToolButtons(); });

document.getElementById('centerBtn').addEventListener('click', ()=>{ centerCameraOnPlayer(); });

function updateToolButtons(){
  ['fillBtn','eraseBtn','rectBtn','panBtn'].forEach(id=>{
    document.getElementById(id).classList.toggle('primary', state.tool === id.replace('Btn',''));
  });
}

/* create/resize/clear */
document.getElementById('regenBtn').addEventListener('click', ()=>{
  const w = Math.max(10,Math.min(500,Number(mapWInput.value) || 120));
  const h = Math.max(8,Math.min(120,Number(mapHInput.value) || 20));
  state.mapW = w; state.mapH = h;
  state.map = createEmptyMap(w,h);
  // put a simple starting road horizontally
  const mid = Math.floor(h/2);
  for(let x=0;x<w;x++){
    state.map[mid][x] = 2;
  }
  // place player near left start
  state.player.x = 2*state.tileSize;
  state.player.y = mid*state.tileSize + state.tileSize/2;
  resetCamera();
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  state.map = createEmptyMap(state.mapW, state.mapH);
});

document.getElementById('exportBtn').addEventListener('click', ()=>{
  const obj = {
    w: state.mapW, h: state.mapH, ts: state.tileSize, map: state.map,
    player: { x: state.player.x, y: state.player.y, radius: state.player.radius }
  };
  mapJSON.value = JSON.stringify(obj, null, 2);
});

document.getElementById('importBtn').addEventListener('click', ()=>{
  try{
    const obj = JSON.parse(mapJSON.value);
    if(obj.w && obj.h && obj.map){
      state.mapW = obj.w; state.mapH = obj.h; state.tileSize = obj.ts || state.tileSize;
      state.map = obj.map;
      if(obj.player){ state.player.x = obj.player.x || state.player.x; state.player.y = obj.player.y || state.player.y; }
      tileSizeInput.value = state.tileSize;
      mapWInput.value = state.mapW; mapHInput.value = state.mapH;
      resetCamera();
    } else {
      alert('Invalid map JSON');
    }
  } catch(e){
    alert('Invalid JSON: '+e.message);
  }
});

document.getElementById('downloadBtn').addEventListener('click', ()=>{
  const blob = new Blob([mapJSON.value || JSON.stringify({w:state.mapW,h:state.mapH,ts:state.tileSize,map:state.map},null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'map.json'; a.click();
  URL.revokeObjectURL(url);
});

document.getElementById('applyTileSize').addEventListener('click', ()=>{
  const ts = Math.max(16, Math.min(64, Number(tileSizeInput.value) || 32));
  state.tileSize = ts;
  resetCamera();
});

document.getElementById('resetCamera').addEventListener('click', ()=>resetCamera());

document.getElementById('helpLink').addEventListener('click', e=>{
  e.preventDefault();
  alert('Help:\n- Use the palette to choose a tile.\n- In EDIT mode: paint with left click, right click to erase. Tools: Fill, Rect, Pan.\n- Export map to JSON, then import or download it.\n- Toggle PLAY to control the black-dot player with WASD/Arrows. The camera follows horizontally.');
});

/* ----- utility: center camera, reset ----- */
function centerCameraOnPlayer(){
  state.camera.x = state.player.x - state.camera.w/2;
  state.camera.y = state.player.y - state.camera.h/2;
  clampCamera();
}
function resetCamera(){
  state.camera.w = canvas.width;
  state.camera.h = canvas.height;
  centerCameraOnPlayer();
}

/* ----- setup on load ----- */
function init(){
  // initial canvas sizing: ensure internal resolution matches CSS size for crisp
  function resizeCanvasToDisplaySize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(320, Math.floor(rect.width * dpr));
    const h = Math.max(240, Math.floor(rect.height * dpr));
    if(canvas.width !== w || canvas.height !== h){
      canvas.width = w; canvas.height = h;
      // adjust camera width/height so it uses canvas pixel dimensions
      state.camera.w = canvas.width;
      state.camera.h = canvas.height;
    }
  }
  window.addEventListener('resize', ()=>{ resizeCanvasToDisplaySize(); resetCamera(); });
  // initialize state
  ensureMap();
  mapWInput.value = state.mapW; mapHInput.value = state.mapH;
  tileSizeInput.value = state.tileSize;
  rebuildPalette();
  updateToolButtons();
  resizeCanvasToDisplaySize();
  resetCamera();
  lastTime = performance.now();
  requestAnimationFrame(step);
}
init();

/* put a gentle default map for quick start */
(function quickSeed(){
  // Create a simple horizontal city strip
  state.map = createEmptyMap(state.mapW, state.mapH);
  const mid = Math.floor(state.mapH/2);
  for(let x=0;x<state.mapW;x++){
    state.map[mid][x] = 2; // road
    if(x%10===0){
      state.map[mid-1][x] = 1;
      state.map[mid+1][x] = 1;
      // small building block beside roads
      for(let by=mid-3; by<=mid-2; by++){
        for(let bx=x+1; bx<=x+3 && bx<state.mapW; bx++){
          state.map[by][bx] = 1;
        }
      }
    }
  }
  // a river at lower area for variety
  for(let x=10;x<state.mapW-10;x++){
    state.map[state.mapH-3][x] = 4;
    state.map[state.mapH-4][x] = 4;
  }
  // initial player start
  state.player.x = 3*state.tileSize;
  state.player.y = mid*state.tileSize + state.tileSize/2;
})();

</script>
</body>
</html>